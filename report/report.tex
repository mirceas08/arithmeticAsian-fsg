\title{{\sc Forward shooting grid for arithmetic average options}\\
{\normalsize Assignment for \textit{Applied Numerical Finance} class}}
\author{\normalsize
        Mircea Simionica\\
        \normalsize  Student ID: 1814516\\
        \normalsize  Bocconi University\\
        \normalsize  Milan, Italy\\
        \normalsize   mircea.simionica@gmail.com \\
        \normalsize   mircea.simionica@studbocconi.it
}
\date{}

\documentclass[12pt]{article}
%\usepackage[square,sort,comma,numbers]{natbib}
\usepackage{wrapfig}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{xcolor}
\lstset { %
    language=C++,
    backgroundcolor=\color{black!5}, % set backgroundcolor
    basicstyle=\footnotesize,% basic font setting
}
\usepackage[margin=3cm]{geometry}
\usepackage{natbib}
\usepackage{amssymb,amsmath}
\usepackage{mathrsfs}
\usepackage{caption}
\usepackage{graphicx}
\usepackage{tabularx}
\usepackage{tabu}
\usepackage{booktabs}% for better rules in the table
\usepackage{hyperref}
\numberwithin{equation}{section}
\newcommand{\bs}{\mathbf{s}}
\newcommand{\br}{\mathbf{r}}
\newcommand{\bu}{\mathbf{u}}
\newcommand{\appsection}[1]{\let\oldthesection\thesection
  \renewcommand{\thesection}{Appendix \oldthesection}
  \section{#1}\let\thesection\oldthesection}

\begin{document}
\maketitle
\pagestyle{plain}
\pagenumbering{roman}
\tableofcontents
\newpage
\clearpage
\pagenumbering{arabic}

\section{Introduction}
The forward shooting grid method is a modified binomial model that allows the valuation of different kinds of lookback options. This analysis studies the application of the forward shooting grid to Asian options. The payoff of these type of options depends on the average of the underlying asset price over some specified period of time. Asian options may look attractive to some investors because less expensive and less volatile. For this reasons they provide a cost-efficient way of hedging. \\
\newline
The mathematical finance literature has delved into the valuation of Asian options, which results non-trivial. Assuming stock prices follow a lognormal distribution, the geometric average presents an analytic form. However, in practice, the standard form of averaging is arithmetic. For the European case, some methods (including Monte Carlo simulation, analytic approximations through moment matching and convolution using Fast Fourier Transform) have been proposed. As is often the case, the opportunity of early exercise complicates the valuation approach even more. The forward shooting grid presents itself as an alternative to other methods.
\section{Forward shooting grid method}
A standard binomial method can Markovianize the problem by introducing a state variable. In our case this will be the arithmetic average of the stock price, that will be attached to every node of the tree. The complication is that the number of possible averages grows exponentially with the number of time steps in the tree. In fact, the tree for the arithmetic average is not recombining as it is for the geometric case. Hull and White \cite{HullWhite} suggested to keep track only of a smaller subset of possible values for the arithmetic average at each node. Standard backwards recursion is then used to value the option and interpolation is applied when necessary. Assuming classic notation for a binomial model, the implementation of the forward shooting grid can be sketched as follows:
\begin{itemize}
\item Build a standard binomial tree for the stock price. For each node $(i,j)$ the value of the asset $S$ will be
\begin{equation*}
S(i,j) = S_0u^{i-j}d^j
\end{equation*}
\item Construct the tree of representative values for the arithmetic average. Each node $(i,j)$ is assigned a vector of averages, whose elements are spaced between a minimum and maximum average. A way of calculating these values is considering the value of averages generated by the path of lowest and highest prices, respectively, up to node $(i,j)$, as illustrated in Figure \ref{averages}.
\begin{figure}[h]
	\centering
	\includegraphics[scale=0.6]{averages}
	\caption{Paths leading to minimum and maximum average}
	\label{averages}
\end{figure}
\item Compute the value of the option by backward recursion. Firstly, set the payoff $X(T)$ at the end nodes of the tree as
\begin{itemize}
\item $X(T) = (S_{average}-K)^+$ for fixed strike call
\item $X(T) = (S(T)-S_{average})^+$ for floating strike call
\end{itemize}
The recursion step can be outlined as follows. Let us consider a generic node $(i,j)$, which will be coupled with a vector of averages $A(i,j)$. At the next time slice, the updating rule of $A$, corresponding to an up or down move of the stock, will provide:
\begin{equation*}
A_{u} = \frac{(i+1)A_{ij} + uS_{ij}}{i+2} \quad \text{and} \quad A_{d} = \frac{(i+1)A_{ij} + dS_{ij}}{i+2}
\end{equation*}
These vectors will not coincide with the vector of representative averages computed at the second step. Thus, interpolation has to be applied in order to retrieve option values at $A_{u}$ and at $A_{d}$, denoted by $V(i+1,j+1,A_{u})$ and $V(i+1,j,A_{d})$.
\item Now standard backward recursion can be employed. As an example, for an European call
\begin{equation*}
V(i,j) = e^{-r\Delta t}[pV(i+1,j+1,A_{u}) + (1-p)V(i+1,j,A_{d})]
\end{equation*}
This way the root of the tree is reached, where there exists only one average, therefore a unique option price.
\end{itemize}

\section{Numerical and financial remarks}
Some remarks are in order.
\begin{itemize}
\item Once we calculate the minimum and maximum average for each node $(i,j)$ we need to decide how to space values in between them. Representative averages can be equally or logarithmically spaced via the following formulas:
\begin{align*}
A(i,j,k) &= \frac{M-k}{M}A_{max}(i,j) + \frac{k}{M}A_{min}(i,j), \text{for } k = 0,1,...,M \\
A(i,j,k) &= \text{exp} \left( \frac{M-k}{M}ln(A_{max}(i,j)) + \frac{k}{M}ln(A_{min}(i,j)) \right ), \text{for } k = 0,1,...,M
\end{align*}
The system described in Figure \ref{averages} is not the only way to go. Other choices of $A_{min}(i,j)$ and $A_{max}(i,j)$ are out there, as in \cite{Barraquand} and \cite{Klassen}. 
\item Another question concers the interpolation required in the backward recursion. When the updating rule does not return an exact match (which always happens when we deal with big trees and a high number of representative averages) we can, for every element of the vector, take the closest from above, take the closest from below, or interpolate. The first two solutions do not work very well in practice, so interpolation is a must. Now, should we employ linear or quadratic interpolation? Quadratic interpolation is preferable, but may start to be effective only for a finer mesh. The code implements quadratic interpolation as well. However, its behaviour is buggy along the edges of the tree so linear interpolation is used. Moreover, it might happen that some extreme values returned by the updating rule may not fall inside the representative averages vector. In that case, extrapolation should be used. The code, however takes the closest from above when the values falls outside from the bottom and the closest from below for the opposite case.
\item Finally, the most critical part is the choice of the number of time steps in the grid and the size of the vector of representative averages. Since we are not considering the whole set of averages, but only a subset of them, the pricing procedure will not converge to exact option values unless the number of representative averages is large enough and well allocated with the size of the time step. As we depart from the root of the tree, more representative averages are necessary for convergence. The previous version of the code implemented a fixed number of representative averages, that had to be large enough compared to the number of time steps. After the class presentations and the professor Battauz's suggestion, the code now attaches to every node a number of representative averages based on the position in the tree, i.e. proportionally to the index $j$.
\item From a financial standpoint, the code is implemented for continous sampling, meaning that every node $(i,j)$ is coupled with a vector of representative averages, which is a function of the indices $i$ and $j$ themselves. However, we are more interested into discrete sampling for practical reasons. My intuition is that, in this case, the vector of representative averages should be computed only at indices $j$ where sampling happens. For the other indices, consider the generic node $(i,j)$ where sampling is not applied. The node $(i,j)$ can inherit the average of the vectors of its two predecessors, $(i-1,j-1)$ and $(i,j-1)$.
\end{itemize}

\section{Programming remarks}
The code is written in C++ and more details can be found in the docs at \url{https://github.com/mirceas08/arithmeticAverage-fsg}. The main issue encountered in coding the forward shooting grid concerned efficient memory usage, particularly regarding the data structure that holds the binomial lattices. One of the early versions, which still attached a fixed number of representative averages to each node, ended badly due to memory bottlenecks. That version stored the lattice for S in a matrix of doubles and the lattices for the option price and the averages in a field, i.e. a matrix of vectors. This was a bad way of doing it because the space in memory is allocated on the heap for the entire matrix, even if values are not initialized. And we only need the upper triangular part of a matrix/field. A better (not claiming it is the most optimal one) way to do it is to hold the lattice for S in a sparse matrix (that does not allocate space for uninitialized values) and the other lattices in a C++ vector$<>$ of fields. The vector$<>$ template is an STL container that can grow dinamically, so each element will contain a field of different size, resembling an upper triangular matrix. Improved memory usage came after moving away from a fixed number of representative averages, as professor Battauz suggested.\\
\newline
Another solution would be to not store into memory the vectors of representative averages, but to retrieve them during the backward recursion, everytime we need them. My only concern is that we gain in memory usage but loose in computational performance, since during the backward recursion, at each node we need the vector of averages of the current and next time slice. Travelling back to the root of the tree, computations are overlapping. This brings my mind to dynamic programming and a solution would be to memoize function calls and return the cached results if already available. This point might remain a source for further investigation.

\section{Numerical results}





\nocite{*}

\newpage


\bibliographystyle{plain}
\bibliography{mybib}

\end{document}

